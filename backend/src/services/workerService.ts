import * as sandboxService from './sandboxService';
import * as llmService from './llmService';
import {
  getSubmissionById,
  updateSubmission,
} from './submissionService';
import { PythonComplexityAnalyzer } from '../complexity/python/PythonComplexityAnalyzer';
import sandboxRunner from '../routes/sandbox/sandboxRunner';

import { extractSignature, getWrapperTemplate, saveWrapperTemplate } from './signatureService';
import { generateWrapperViaLLM, validateWrapper } from './wrapperService';

const pythonAnalyzer = new PythonComplexityAnalyzer();

export const processSubmission = async (id: string) => {
  try {
    const submission = await getSubmissionById(id);

    if (!submission) {
      throw new Error('Submission not found');
    }
    
    // IDEMPOTENCY CHECK (Audit Fix)
    if (submission.status === 'completed' || submission.status === 'failed') {
        console.log(`Submission ${id} is already processed. Skipping.`);
        return;
    }

    // CHECK FOR COMPLEXITY MODE (Python + Signature)
    if (submission.language === 'python' && pythonAnalyzer.isComplexityMode(submission.code)) {
        
        console.log(`[Worker] Started processing submission ${id} in Complexity Mode`);

        const sig = extractSignature(submission.code, submission.language);
        if (!sig) {
            throw new Error(`[Worker] Could not extract normalized signature for Complexity Mode`);
        }

        let wrapperTemplate = await getWrapperTemplate(submission.language, sig);
        if (wrapperTemplate) {
            console.log(`[CACHE HIT] Found wrapper for signature ${sig}`);
        } else {
            console.log(`[CACHE MISS - calling LLM] Generating wrapper for signature ${sig}`);
            wrapperTemplate = await generateWrapperViaLLM(sig);
            
            if (!validateWrapper(wrapperTemplate)) {
                throw new Error("Invalid wrapper generated by LLM (Missing {{USER_CODE}} or scaling logs)");
            }
            await saveWrapperTemplate(submission.language, sig, wrapperTemplate);
        }

        console.log(`[Worker] Triggering Python Complexity Analyzer...`);
        
        const complexityResult = await pythonAnalyzer.analyze(
            submission.code, 
            submission.language, 
            sandboxRunner, 
            wrapperTemplate
        );
        
        if (complexityResult.error) {
             console.error(`[Worker] Complexity Analysis failed for ${id}:`, complexityResult.error);
             throw new Error(complexityResult.error);
        }
        
        console.log(`[Worker] Complexity Analysis finished for ${id}. Estimated: ${complexityResult.estimatedComplexity}`);
        console.log(`[Worker] Fetching AI explanation...`);
        
        const t1 = Math.max(complexityResult.executionTimes?.small || 0.000001, 0.000001);
        const t2 = Math.max(complexityResult.executionTimes?.medium || 0.000001, 0.000001);
        const t3 = Math.max(complexityResult.executionTimes?.large || 0.000001, 0.000001);

        const ratio1 = complexityResult.executionTimes ? (t2 / t1) : undefined;
        const ratio2 = complexityResult.executionTimes ? (t3 / t2) : undefined;

        // Use LLM to explain the complexity
        const explanation = await llmService.explain({
            code: submission.code,
            estimatedComplexity: complexityResult.estimatedComplexity || 'Unknown',
            smallTime: complexityResult.executionTimes?.small,
            mediumTime: complexityResult.executionTimes?.medium,
            largeTime: complexityResult.executionTimes?.large,
            ratio1,
            ratio2,
            memoryUsage: 'N/A' // Not tracked in Python complexity wrapper yet
        });

        console.log(`[Worker] Updating DB for submission ${id} with completed status...`);
        await updateSubmission(id, {
            status: 'completed',
            execution_time_small: complexityResult.executionTimes?.small,
            execution_time_medium: complexityResult.executionTimes?.medium,
            execution_time_large: complexityResult.executionTimes?.large,
            estimated_complexity: complexityResult.estimatedComplexity,
            ai_explanation: explanation,
            output: 'Complexity Analysis Completed Successfully',
            complexity: complexityResult.estimatedComplexity
        });
        console.log(`[Worker] Successfully completed submission ${id}`);
        
    } else {
        // STANDARD MODE
        console.log(`[Worker] Started processing submission ${id} in Standard Mode`);
        console.log(`[Worker] Executing code in Sandbox...`);
        
        const sandboxResult = await sandboxService.execute(
          submission.code,
          submission.language,
          submission.input
        );
        
        console.log(`[Worker] Sandbox execution finished for ${id}.`);
        console.log(`[Worker] Fetching AI explanation...`);

        const explanation = await llmService.explain({
          code: submission.code,
          estimatedComplexity: sandboxResult.complexity,
          smallTime: sandboxResult.execution_time,
          memoryUsage: sandboxResult.memory_used
        });

        await updateSubmission(id, {
          status: 'completed',
          execution_time: sandboxResult.execution_time,
          memory_used: sandboxResult.memory_used,
          output: sandboxResult.output,
          complexity: sandboxResult.complexity,
          ai_explanation: explanation,
        });
    }

  } catch (error: any) {
    console.error(`Submission processing failed for ${id}:`, error);
    await updateSubmission(id, {
      status: 'failed',
      error_message: error.message,
    });
  }
};
